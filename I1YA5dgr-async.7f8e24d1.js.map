{"version":3,"sources":["docs/blog/render-times.zh-CN.md?type=text"],"sourcesContent":["\n  import '/Users/vagusx/Projects/ant-design/docs/blog/render-times.zh-CN.md?watch=parent';\n  export const texts = [{\"value\":\"对于重型组件而言，随着时间推移，一些 BUG Fix 或者新增 Feature 很容易不经意间将原本的性能优化给破坏掉。而最近，我们在对 Table 进行重构将一些历史更新导致的性能损失进行排查并恢复。在此，我们介绍一些常用的排查技巧以及常见问题。\",\"paraId\":0},{\"value\":\"在此之前，我们建议你先阅读官方的 \",\"paraId\":1},{\"value\":\"性能工具\",\"paraId\":1},{\"value\":\" 以选择你需要调试的内容。\",\"paraId\":1},{\"value\":\"在大部分情况下，无效的渲染相对于未优化的循环而言，体感并没有那么强烈。但是在某一些场景诸如大型表单、表格、列表下，由于其子组件众多，无效的渲染叠加后其性能影响也十分可怕。\",\"paraId\":2,\"tocIndex\":0},{\"value\":\"举个例子，在 antd v4 中，我们为了提升 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"rowSpan\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" Table Hover 的高亮体验，我们为 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"tr\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 添加了事件监听，同时在 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"td\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 中为选中行添加额外的 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"className\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 以支持多行高亮能力。但是由于 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"td\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 消费了 context 中 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"hoverStartRow\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 和 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"hoverEndRow\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 数据，导致了非相关 Row 都会因为 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"hoverStartRow\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 和 \",\"paraId\":3,\"tocIndex\":0},{\"value\":\"hoverEndRow\",\"paraId\":3,\"tocIndex\":0},{\"value\":\" 变化而\",\"paraId\":3,\"tocIndex\":0},{\"value\":\"重新渲染\",\"paraId\":3,\"tocIndex\":0},{\"value\":\"。\",\"paraId\":3,\"tocIndex\":0},{\"value\":\"诸如此类的问题在重型组件循环往复，因而我们需要一些辅助方式来确定渲染次数。在最新的 \",\"paraId\":4,\"tocIndex\":0},{\"value\":\"rc-table\",\"paraId\":4,\"tocIndex\":0},{\"value\":\" 中，我们封装了一个 \",\"paraId\":4,\"tocIndex\":0},{\"value\":\"useRenderTimes\",\"paraId\":4,\"tocIndex\":0},{\"value\":\" 方法。它会在开发模式下通过 React 的 \",\"paraId\":4,\"tocIndex\":0},{\"value\":\"useDebugValue\",\"paraId\":4,\"tocIndex\":0},{\"value\":\" 将监听的渲染次数标注在 React Dev Tools 上：\",\"paraId\":4,\"tocIndex\":0},{\"value\":\"// Sample Code, please view real world code if needed\\nimport React from 'react';\\n\\nfunction useRenderTimes<T>(props: T) {\\n  // Render times\\n  const timesRef = React.useRef(0);\\n  timesRef.current += 1;\\n\\n  // Cache for prev props\\n  const cacheProps = React.useRef(props);\\n  const changedPropKeys = getDiff(props, cacheProps.current); // Some compare logic\\n\\n  React.useDebugValue(timesRef.current);\\n  React.useDebugValue(changedPropKeys);\\n\\n  cacheProps.current = props;\\n}\\n\\nexport default process.env.NODE_ENV !== 'production' ? useRenderTimes : () => {};\\n\",\"paraId\":5,\"tocIndex\":0},{\"value\":\"一般在组件的根节点上，我们会根据 \",\"paraId\":6,\"tocIndex\":2},{\"value\":\"props\",\"paraId\":6,\"tocIndex\":2},{\"value\":\" 和 \",\"paraId\":6,\"tocIndex\":2},{\"value\":\"state\",\"paraId\":6,\"tocIndex\":2},{\"value\":\" 创建一个 Context 来将聚合数据传递下去。但是在某些情况下可能 Context 实际内容没有变化也触发子组件的重新渲染：\",\"paraId\":6,\"tocIndex\":2},{\"value\":\"// pseudocode\\nconst MyContext = React.createContext<{ prop1: string; prop2: string }>();\\n\\nconst Child = React.memo(() => {\\n  const { prop1 } = React.useContext(MyContext);\\n  return <>{prop1}</>;\\n});\\n\\nconst Root = ({ prop1, prop2 }) => {\\n  const [count, setCount] = React.useState(0);\\n\\n  // Some logic to trigger rerender\\n  React.useEffect(() => {\\n    setCount(1);\\n  }, []);\\n\\n  return (\\n    <MyContext.Provider value={{ prop1, prop2 }}>\\n      <Child />\\n    </MyContext.Provider>\\n  );\\n};\\n\",\"paraId\":7,\"tocIndex\":2},{\"value\":\"在示例中，虽然 \",\"paraId\":8,\"tocIndex\":2},{\"value\":\"prop1\",\"paraId\":8,\"tocIndex\":2},{\"value\":\" 和 \",\"paraId\":8,\"tocIndex\":2},{\"value\":\"prop2\",\"paraId\":8,\"tocIndex\":2},{\"value\":\" 并没有变化，但是显然 MyContext 里的 \",\"paraId\":8,\"tocIndex\":2},{\"value\":\"value\",\"paraId\":8,\"tocIndex\":2},{\"value\":\" 是一个新的 Object 导致子组件即便 \",\"paraId\":8,\"tocIndex\":2},{\"value\":\"prop1\",\"paraId\":8,\"tocIndex\":2},{\"value\":\" 没有变化也会重新渲染。因而我们需要对 Context \",\"paraId\":8,\"tocIndex\":2},{\"value\":\"value\",\"paraId\":8,\"tocIndex\":2},{\"value\":\" 进行 Memo：\",\"paraId\":8,\"tocIndex\":2},{\"value\":\"// pseudocode\\nconst context = React.useMemo(() => ({ prop1, prop2 }), [prop1, prop2]);\\n\\nreturn (\\n  <MyContext.Provider value={context}>\\n    <Child />\\n  </MyContext.Provider>\\n);\\n\",\"paraId\":9,\"tocIndex\":2},{\"value\":\"注：你可以配置 eslint \",\"paraId\":10,\"tocIndex\":2},{\"value\":\"规则\",\"paraId\":10,\"tocIndex\":2},{\"value\":\" 来避免遗漏。\",\"paraId\":10,\"tocIndex\":2},{\"value\":\"此外，参考上面的示例。如果我们将 \",\"paraId\":11,\"tocIndex\":3},{\"value\":\"prop1\",\"paraId\":11,\"tocIndex\":3},{\"value\":\" 和 \",\"paraId\":11,\"tocIndex\":3},{\"value\":\"prop2\",\"paraId\":11,\"tocIndex\":3},{\"value\":\" 都放在 Context 中，那么即便 \",\"paraId\":11,\"tocIndex\":3},{\"value\":\"prop1\",\"paraId\":11,\"tocIndex\":3},{\"value\":\" 没有变化，\",\"paraId\":11,\"tocIndex\":3},{\"value\":\"prop2\",\"paraId\":11,\"tocIndex\":3},{\"value\":\" 变化了，也会导致子组件重新渲染。因而我们可以根据功能将 Context 拆分成多个，从而减小影响范围：\",\"paraId\":11,\"tocIndex\":3},{\"value\":\"// pseudocode\\nconst MyContext1 = React.createContext<{ prop1: string }>();\\nconst MyContext2 = React.createContext<{ prop2: string }>();\\n\\n// Child\\nconst { prop1 } = React.useContext(MyContext1);\\n\\n// Root\\n<MyContext1.Provider value={context1}>\\n  <MyContext2.Provider value={context2}>\\n    <Child />\\n  </MyContext2.Provider>\\n</MyContext1.Provider>;\\n\",\"paraId\":12,\"tocIndex\":3},{\"value\":\"在 \",\"paraId\":13,\"tocIndex\":3},{\"value\":\"rc-table\",\"paraId\":13,\"tocIndex\":3},{\"value\":\" 中，我们将其拆分为多个以优化渲染性能：\",\"paraId\":13,\"tocIndex\":3},{\"value\":\"BodyContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"ExpandedRowContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"HoverContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"PerfContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"ResizeContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"StickyContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"TableContext\",\"paraId\":14,\"tocIndex\":3},{\"value\":\"如果你使用过 Redux，那么你可能会对 \",\"paraId\":15,\"tocIndex\":4},{\"value\":\"useSelector\",\"paraId\":15,\"tocIndex\":4},{\"value\":\" 比较熟悉，它只会在需要消费的数据变更时才会触发更新。在 React 中，也同样有相关的 RFC(\",\"paraId\":15,\"tocIndex\":4},{\"value\":\"#118\",\"paraId\":15,\"tocIndex\":4},{\"value\":\")(\",\"paraId\":15,\"tocIndex\":4},{\"value\":\"#119\",\"paraId\":15,\"tocIndex\":4},{\"value\":\")，未来在 React 18 也将实装：\",\"paraId\":15,\"tocIndex\":4},{\"value\":\"在 API 正式落地之前，业界也有不少三方库实现该 API（当然，你也可以直接使用 redux）。通过 \",\"paraId\":16,\"tocIndex\":4},{\"value\":\"useContextSelector\",\"paraId\":16,\"tocIndex\":4},{\"value\":\" 就不再需要考虑功能拆分 Context 的问题，这也降低了开发者的心智负担：\",\"paraId\":16,\"tocIndex\":4},{\"value\":\"// pseudocode\\nconst Child = React.memo(() => {\\n  const prop1 = useContextSelector(MyContext, (context) => context.prop1);\\n  return <>{prop1}</>;\\n});\\n\",\"paraId\":17,\"tocIndex\":4},{\"value\":\"在通过各种方式优化过后，我们还不得不面对一个问题。如果某些渲染需要通过外界的 render 方式，并且碰巧该方式使用了闭包。那么 \",\"paraId\":18,\"tocIndex\":5},{\"value\":\"React.memo\",\"paraId\":18,\"tocIndex\":5},{\"value\":\" 是无法感知的：\",\"paraId\":18,\"tocIndex\":5},{\"value\":\"// pseudocode\\nimport React from 'react';\\n\\nconst MyComponent = React.memo(({ valueRender }: { valueRender: () => React.ReactElement }) =>\\n  valueRender(),\\n);\\n\\nconst App = () => {\\n  const countRef = React.useRef(0);\\n  const [, forceUpdate] = React.useState({});\\n\\n  React.useEffect(() => {\\n    countRef.current += 1;\\n    forceUpdate({});\\n  }, []);\\n\\n  // In real world, class component often meet this by `this.state`\\n  const valueRender = React.useCallback(() => countRef.current, []);\\n\\n  return <MyComponent valueRender={valueRender} />;\\n};\\n\",\"paraId\":19,\"tocIndex\":5},{\"value\":\"由于闭包的存在，在调用 \",\"paraId\":20,\"tocIndex\":5},{\"value\":\"render\",\"paraId\":20,\"tocIndex\":5},{\"value\":\" 方法之前我们无法确定组件最终形态是否发生变化，这也是为何在 antd v4 早期我们通过 memo 对 Table 进行了优化而随着时间推移又将一部分移除的原因（实际上，Table 仍然有一些场景会遇到这个问题需要解决）。\",\"paraId\":20,\"tocIndex\":5},{\"value\":\"考虑到 Table 提供了 \",\"paraId\":21,\"tocIndex\":5},{\"value\":\"shouldCellUpdate\",\"paraId\":21,\"tocIndex\":5},{\"value\":\" 方法，我们准备未来调整 Table 渲染逻辑。当 Parent 节点渲染时，Table 会完整的重新渲染，而当 Table 内部更新时（例如水平滚动位置同步），则会命中缓存而跳过。\",\"paraId\":21,\"tocIndex\":5},{\"value\":\"antd 的 Table 优化仍在进行中，我们也会持续关注 React 的新特性，以及社区的新思路。如果你有任何想法，欢迎在 GitHub 留言讨论。此外，对于自行研发组件的建议，我们推荐在每次完成优化后，都要创建对应的测试用例，并且备注来源 issue 以便于未来的回溯。以上。\",\"paraId\":22,\"tocIndex\":6}];\n  "],"names":[],"mappings":"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"}